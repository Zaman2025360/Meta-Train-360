import { Mesh } from 'three';
import { Pointer } from './pointer.js';
import { PointerEvent } from './event.js';
import { CameraRayIntersector } from './intersections/ray.js';
import { generateUniquePointerId } from './pointer/index.js';
import { getClosestUV } from './utils.js';
function htmlEventToCoords(element, e, target) {
    if (!(e instanceof globalThis.MouseEvent)) {
        return target.set(0, 0);
    }
    const { width, height, top, left } = element.getBoundingClientRect();
    const x = e.pageX - left;
    const y = e.pageY - top;
    return target.set((x / width) * 2 - 1, -(y / height) * 2 + 1);
}
/**
 * sets the `pointerTypePrefix` to `"screen-"`. Therefore, a event with pointerType `touch` is forwarded to the scene as `"screen-touch"`
 */
export function forwardHtmlEvents(fromElement, getCamera, scene, options) {
    return forwardEvents(fromElement, 
    //backwards compatibility
    typeof getCamera === 'function' ? getCamera : () => getCamera, scene, htmlEventToCoords.bind(null, fromElement), fromElement.setPointerCapture.bind(fromElement), fromElement.releasePointerCapture.bind(fromElement), {
        pointerTypePrefix: 'screen-',
        ...options,
    });
}
function portalEventToCoords(e, target) {
    if (!(e instanceof PointerEvent)) {
        return target.set(0, 0);
    }
    if (!(e.object instanceof Mesh)) {
        return target.set(0, 0);
    }
    getClosestUV(target, e.point, e.object);
    target.multiplyScalar(2).addScalar(-1);
    return target;
}
export function forwardObjectEvents(fromPortal, getCamera, scene, options) {
    return forwardEvents(fromPortal, getCamera, scene, portalEventToCoords, fromPortal.setPointerCapture.bind(fromPortal), fromPortal.releasePointerCapture.bind(fromPortal), options);
}
/**
 * @returns cleanup function
 */
function forwardEvents(from, getCamera, scene, toCoords, setPointerCapture, releasePointerCapture, options = {}) {
    const forwardPointerCapture = options?.forwardPointerCapture ?? true;
    const pointerMap = new Map();
    const pointerTypePrefix = options.pointerTypePrefix ?? 'forward-';
    const getInnerPointer = ({ pointerId = -1, pointerType = 'mouse', pointerState }) => {
        let innerPointer = pointerMap.get(pointerId);
        if (innerPointer != null) {
            return innerPointer;
        }
        pointerMap.set(pointerId, (innerPointer = new Pointer(generateUniquePointerId(), `${pointerTypePrefix}${pointerType}`, pointerState, new CameraRayIntersector((nativeEvent, coords) => {
            toCoords(nativeEvent, coords);
            return getCamera();
        }, options), getCamera, undefined, forwardPointerCapture ? setPointerCapture.bind(null, pointerId) : undefined, forwardPointerCapture ? releasePointerCapture.bind(null, pointerId) : undefined, options)));
        return innerPointer;
    };
    const lastMoveEventMap = new Map();
    const pointerMoveListener = (e) => lastMoveEventMap.set(getInnerPointer(e), e);
    const pointerCancelListener = (e) => getInnerPointer(e).cancel(e);
    const pointerDownListener = (e) => void (hasButton(e) && getInnerPointer(e).down(e));
    const pointerUpListener = (e) => void (hasButton(e) && getInnerPointer(e).up(e));
    const wheelListener = (e) => getInnerPointer(e).wheel(scene, e, false);
    const pointerLeaveListener = (e) => {
        const pointer = getInnerPointer(e);
        pointer.exit(e);
        lastMoveEventMap.delete(pointer);
    };
    from.addEventListener('pointermove', pointerMoveListener);
    from.addEventListener('pointercancel', pointerCancelListener);
    from.addEventListener('pointerdown', pointerDownListener);
    from.addEventListener('pointerup', pointerUpListener);
    from.addEventListener('wheel', wheelListener);
    from.addEventListener('pointerleave', pointerLeaveListener);
    return {
        destroy() {
            from.removeEventListener('pointermove', pointerMoveListener);
            from.removeEventListener('pointercancel', pointerCancelListener);
            from.removeEventListener('pointerdown', pointerDownListener);
            from.removeEventListener('pointerup', pointerUpListener);
            from.removeEventListener('wheel', wheelListener);
            from.removeEventListener('pointerleave', pointerLeaveListener);
            lastMoveEventMap.clear();
        },
        update() {
            for (const [pointer, lastMoveEvent] of lastMoveEventMap.entries()) {
                if (lastMoveEvent == null) {
                    continue;
                }
                pointer.move(scene, lastMoveEvent);
                if (options.alwaysUpdate === true) {
                    continue;
                }
                lastMoveEventMap.set(pointer, undefined);
            }
        },
    };
}
function hasButton(val) {
    return val.button != null;
}
